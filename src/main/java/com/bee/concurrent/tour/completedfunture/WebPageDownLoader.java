package com.bee.concurrent.tour.completedfunture;import com.google.common.util.concurrent.ThreadFactoryBuilder;import java.util.ArrayList;import java.util.List;import java.util.concurrent.*;import java.util.stream.Collectors;/** * 一个展示CompletableFuture用法的例子.模拟一个网页下载器，利用多个线程并行下载 * * @author yangying * @version 1.0 * @since 2022/7/2 **/public class WebPageDownLoader {    private final List<String> urls = new ArrayList<>();    private ThreadPoolExecutor threadPoolExecutor;    private List<String> webContent = new ArrayList();    public WebPageDownLoader(){        urls.add("http://www.baidu.com");        urls.add("http://www.google.com");        int coreSize  = Runtime.getRuntime().availableProcessors()+1;        int maxSize = 30;        BlockingQueue blockingQueue = new LinkedBlockingQueue<>(100);        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("download-page-%d").build();        RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.CallerRunsPolicy();        threadPoolExecutor = new ThreadPoolExecutor(coreSize, maxSize, 0, TimeUnit.MILLISECONDS,                blockingQueue, threadFactory, rejectedExecutionHandler);    }    /**     * 利用线程池和Future完成异步并行获取     */    public void downLoadWayOne(){        webContent.clear();        List<Future<String>> futures = new ArrayList<>();        urls.forEach(url->{            Future<String> future = threadPoolExecutor.submit(()->{                return doDownload(url);            });            futures.add(future);        });        futures.forEach(future->{            try {                webContent.add(future.get());            } catch (InterruptedException | ExecutionException e) {                throw new RuntimeException(e);            }        });        threadPoolExecutor.shutdown();        boolean loop =true;        do{            try {                loop = !threadPoolExecutor.awaitTermination(1000,TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                throw new RuntimeException(e);            }        }while (loop);    }    /**     * 利用CompletableFutures.supplyAsync()完成异步并行获取     */    public void downLoadWayTwo(){        webContent.clear();        List<CompletableFuture<String>> futures = new ArrayList<>();        urls.forEach(url->{            CompletableFuture<String> future = CompletableFuture.supplyAsync(()->{               return doDownload(url);            });            futures.add(future);        });        futures.forEach(future->{            try {                webContent.add(future.get());            } catch (InterruptedException | ExecutionException e) {                throw new RuntimeException(e);            }        });    }    /**     * 利用CompletableFutures.supplyAsync()完成异步并行获取,再下载任务完成后，利用利用CompletableFutures.thenApply(Funciton funciton)进行加工     */    public void downLoadWayThree(){        webContent.clear();        List<CompletableFuture<String>> futures = new ArrayList<>();        urls.forEach(url->{            CompletableFuture<String> future = CompletableFuture.supplyAsync(()->{                return doDownload(url);            }).thenApply(result->{                return result.replace("i","you");            });            futures.add(future);        });        futures.forEach(future->{            try {                webContent.add(future.get());            } catch (InterruptedException | ExecutionException e) {                throw new RuntimeException(e);            }        });    }    /**     * 利用CompletableFutures.AllOf()完成异步并行获取     */    public void downLoadWayFour(){        webContent.clear();        final List<CompletableFuture<String>> pageContentFutures = urls.stream().map(url->doDownloadAsyn(url)).collect(Collectors.toList());        CompletableFuture<Void> allFutures = CompletableFuture.allOf(                pageContentFutures.toArray(new  CompletableFuture[pageContentFutures.size()]));        CompletableFuture<List<String>> allPageContentsFuture =  allFutures.thenApply(v->{            return pageContentFutures.stream().map(pageContentFuture-> {                try {                    return pageContentFuture.get();                } catch (InterruptedException | ExecutionException e) {                    throw new RuntimeException(e);                }            }).collect(Collectors.toList());        });        try {            webContent = allPageContentsFuture.get();        } catch (InterruptedException | ExecutionException e) {            throw new RuntimeException(e);        }    }    private String doDownload(String url){        return  "["+Thread.currentThread().getName()+"] i'm downloading:"+url;    }    private CompletableFuture<String> doDownloadAsyn(String url){        return CompletableFuture.supplyAsync(()->{            return doDownload(url);        });    }    public static void main(String[] args) {        WebPageDownLoader webPageDownLoader = new WebPageDownLoader();        webPageDownLoader.downLoadWayOne();        webPageDownLoader.webContent.forEach(System.out::println);        webPageDownLoader.downLoadWayTwo();        webPageDownLoader.webContent.forEach(System.out::println);        webPageDownLoader.downLoadWayThree();        webPageDownLoader.webContent.forEach(System.out::println);        webPageDownLoader.downLoadWayFour();        webPageDownLoader.webContent.forEach(System.out::println);    }}