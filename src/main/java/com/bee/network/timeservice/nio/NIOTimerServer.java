package com.bee.network.timeservice.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.time.LocalDateTime;import java.util.Iterator;import java.util.Set;/** * 一个基于tcp/ip协议的时间服务器，提供查询时间的服务。使用java NIO 多路复用器实现<br><br/> * 使用Socket套接字实现网络通讯，客户端与服务端之间的协议非常简单:客户端可以发送任何内容，服务端接受客户端请求内容，每读取一行，则获取一次当前时间，并返回给客户端 * * @author yangying * @version 1.0 * @since 2022/7/12 **/public class NIOTimerServer implements Runnable {    private final int port;    private Selector selector;    private ServerSocketChannel serverSocketChannel;    private volatile boolean stop;    public NIOTimerServer(int port) {        this.port = port;        //init,初始化ServerSocketChannel和Selector，并将ServerSocketChannel与Selector实例绑定        init();    }    //初始化ServerSocketChannel和Selector，并将ServerSocketChannel与Selector实例绑定    private void init() {        try {            selector = Selector.open();            serverSocketChannel = ServerSocketChannel.open();            serverSocketChannel.configureBlocking(false);            serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//register()的后一个参数是ops，用一个位图指明需要监听的选项类型        } catch (IOException e) {            throw new RuntimeException(e);        }    }    public void stop() {        stop = true;    }    @Override    public void run() {        while (!stop) {            try {                //依赖jdk selector的实现和操作系统提供的epoll机制，轮询是否有就绪的通道                selector.select(1000);                Set<SelectionKey> keys = selector.selectedKeys();                if (!keys.isEmpty()) {                    System.out.println(Thread.currentThread().getName() + ":get some key:" + keys.size());                }                Iterator<SelectionKey> iterator = keys.iterator();                SelectionKey key = null;                while (iterator.hasNext()) {                    key = iterator.next();                    iterator.remove();                    try {                        handleInput(key);                    } catch (Exception e) {                        if (key != null) {                            key.cancel();                            if (key.channel() != null) {                                key.channel().close();                            }                        }                    }                }            } catch (IOException e) {                throw new RuntimeException(e);            }        }        //关闭Selector        if (selector != null) {            try {                selector.close();            } catch (IOException e) {                throw new RuntimeException(e);            }        }    }    /**     * 处理客户端链接请求。从这个方法的实现可以看到，与使用BIO相比，使用Selector处理更复杂     *     * @param key     */    private void handleInput(SelectionKey key) throws IOException {        if (!key.isValid()) {            return;        }        if (key.isAcceptable()) {//支持accept的key，需要创建连接，并把新的连接通道(SocketChannel)注册到selector上，注册时选择监听读取操作            System.out.println(Thread.currentThread().getName() + ":accept new connect");            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();            SocketChannel sc = ssc.accept();            sc.configureBlocking(false);            sc.register(selector, SelectionKey.OP_READ);        }        if (key.isReadable()) {//支持读取操作的key            //从SocketChannel中读取请求到ByteBuffer            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);            SocketChannel sc = (SocketChannel) key.channel();            int byteLen = sc.read(byteBuffer);            if (byteLen > 0) {                byteBuffer.flip();                byte[] requestBytes = new byte[byteBuffer.remaining()];                byteBuffer.get(requestBytes);                System.out.println(Thread.currentThread().getName() + ":receive request:" + new String(requestBytes));                //将响应信息写入到ByteBuffer，返回给客户端                String localDateTime = LocalDateTime.now().toString();                byte[] respBytes = localDateTime.getBytes();                ByteBuffer writeBuffer = ByteBuffer.allocate(respBytes.length);                writeBuffer.put(respBytes);                writeBuffer.flip();                sc.write(writeBuffer);                System.out.println(Thread.currentThread().getName() + ":send response fin");            } else if(byteLen<0){                key.cancel();                sc.close();            }        }    }}