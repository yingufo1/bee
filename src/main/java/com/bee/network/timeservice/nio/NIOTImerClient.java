package com.bee.network.timeservice.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;/** * 一个基于tcp/ip协议的时间服务客户端，。<br></br>使用java NIO 多路复用器实现 * 使用Socket套接字实现网络通讯，客户端与服务端之间的协议非常简单:客户端可以发送任何内容，服务端接受客户端请求内容，每读取一行，则获取一次当前时间，并返回给客户端 * * @author yangying * @version 1.0 * @since 2022/7/12 **/public class NIOTImerClient implements Runnable {    private Selector selector;    private final int port;    private final String host;    private SocketChannel socketChannel;    private volatile boolean stop;    public static void main(String[] args) {        NIOTImerClient niotImerClient = new NIOTImerClient("127.0.0.1", 8080);        new Thread(niotImerClient, "client-thread").start();    }    public NIOTImerClient(String host, int port) {        this.host = host;        this.port = port;        try {            selector = Selector.open();            socketChannel = SocketChannel.open();            socketChannel.configureBlocking(false);        } catch (IOException e) {            e.printStackTrace();            System.exit(1);        }    }    public void run() {        try {            connect();        } catch (IOException ie) {            ie.printStackTrace();            System.exit(1);        }        while (!stop) {            try {                selector.select(1000);                Set<SelectionKey> selectionKeys = selector.selectedKeys();                Iterator<SelectionKey> it = selectionKeys.iterator();                SelectionKey key = null;                while (it.hasNext()) {                    key = it.next();                    it.remove();                    try {                        sendRequest(key);                    }catch (Exception e){                        if (key != null) {                            key.cancel();                            if (key.channel() != null)                                key.channel().close();                        }                    }                }            } catch (IOException e) {                e.printStackTrace();                System.exit(1);            }        }        if (selector != null) {            try {                selector.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    private void connect() throws IOException {        if (socketChannel.connect(new InetSocketAddress(host, port))) {            socketChannel.register(selector, SelectionKey.OP_READ);            doWrite(socketChannel);        } else {            socketChannel.register(selector, SelectionKey.OP_CONNECT);        }    }    private void doWrite(SocketChannel sc) throws IOException {        byte[] request = "QUERY TIME ORDER".getBytes();        ByteBuffer byteBuffer = ByteBuffer.allocate(request.length);        byteBuffer.put(request);        byteBuffer.flip();        sc.write(byteBuffer);        if (!byteBuffer.hasRemaining()) {            System.out.println("Send commond to server succeed.");        }    }    private void sendRequest(SelectionKey key) throws IOException {        if (key.isValid()) {            SocketChannel sc = (SocketChannel) key.channel();            if (key.isConnectable()) {                if (sc.finishConnect()) {                    sc.register(selector, SelectionKey.OP_READ);                    doWrite(sc);                } else {                    System.exit(1);                }            }            System.out.println(Thread.currentThread().getName() + ":get ready for read:"+key.isReadable());            if (key.isReadable()) {                System.out.println(Thread.currentThread().getName() + ":get something resp");                ByteBuffer readBuffer = ByteBuffer.allocate(1024);                int readBytes = sc.read(readBuffer);                StringBuilder sb = new StringBuilder();                if (readBytes > 0) {                    readBuffer.flip();                    sb.append(readBuffer.get());                    System.out.println(Thread.currentThread().getName() + "resp:" + sb);                    this.stop = true;                } else if (readBytes < 0) {                    key.cancel();                    sc.close();                }            }        }    }}