package com.bee.network.timeservice.netty;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;/** * TODO:class description * * @author yangying * @version 1.0 * @since 2022/7/12 **/public class TimerServer {    private int port;    public TimerServer(int port){        this.port = port;    }    public void run(){        //EventloopGroup是一个处理I/O操作的多线程的时间循环，一般分为boss group 和worker group。boss是服务端用来监听和接受新连接，worker利用        //从boss传递过来的连接，接收实际的请求和处理响应。个人理解即是reactor模式        EventLoopGroup boss = new NioEventLoopGroup();        EventLoopGroup workers = new NioEventLoopGroup();        //ServerBootstrap是一个用来安装服务端的辅助类，避免直接使用Channel的繁琐        ServerBootstrap boot = new ServerBootstrap();        boot.group(boss,workers)                .channel(NioServerSocketChannel.class)//指定接受连接的Channel，这里是NioServerSocketChannel                //指定child的ChannelHandler，使用ChannelInitializer来初始化一系列ChannelHandler，一般是SocketChannel pipeline中添加ChannelHandler                .childHandler(new ChannelInitializer<SocketChannel>() {                    @Override                    protected void initChannel(SocketChannel ch) throws Exception {                        ch.pipeline().addLast(new LineBasedFrameDecoder(1024));                        ch.pipeline().addLast(new StringDecoder());                        ch.pipeline().addLast(new DiscardHandler());//往pipeline中添加指定的ChannelHandler，通常是根据实际功能实现的子类，比如这里的DiscardHandler                    }                })                //指定tcp的选项，option指server端接受创建连接的选项，childoption指被ServerChannel accept的Channel的选项                .option(ChannelOption.SO_BACKLOG,128).childOption(ChannelOption.SO_KEEPALIVE,true);        // Bind and start to accept incoming connections.        ChannelFuture f = boot.bind(port);        System.out.println("the server is ready");        try {            // Wait until the server socket is closed.            // In this example, this does not happen, but you can do that to gracefully            // shut down your server.            f.channel().closeFuture().sync();        } catch (InterruptedException e) {            throw new RuntimeException(e);        }finally {            workers.shutdownGracefully();            boss.shutdownGracefully();        }        System.out.println("the server is closed");    }    public static void main(String[] args) {        new TimerServer(8080).run();    }}