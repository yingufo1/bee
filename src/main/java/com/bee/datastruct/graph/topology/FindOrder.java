package com.bee.datastruct.graph.topology;import java.util.*;/** * 剑指 Offer II 113. 课程顺序:https://leetcode.cn/problems/QA2IGt/ * * @author yangying * @version 1.0 * @since 2022/6/9 **/public class FindOrder {    public int[] findOrder(int numCourses, int[][] prerequisites) {        Map<Integer, List<Integer>> graph = new HashMap<>();//用于保存每个节点的出边        int[] inDegrees = new int[numCourses];//用来表示每个节点的入度        for (int i = 0; i < numCourses; i++) {            graph.put(i, new LinkedList<>());        }        for (int[] prerequisite : prerequisites) {            graph.get(prerequisite[1]).add(prerequisite[0]);//维护先修的课prerequisite[1]的后续课程列表，把prerequisite[0]添加到列表            inDegrees[prerequisite[0]]++;//后修课程的入度加1        }        Queue<Integer> queue = new LinkedList<>();//在后续遍历过程中保存入度为0的节点        for(int i=0;i<numCourses;i++){            if(inDegrees[i] == 0){                queue.offer(i);            }        }        List<Integer> order = new LinkedList<>();        int i =0;        while (!queue.isEmpty()) {            int course = queue.poll();            order.add(course);            for (int next :graph.get(course)){//找出course之前的所有需要修习的课程                inDegrees[next]--;//这些课程的入度减一                if(inDegrees[next] == 0){                    queue.offer(next);                }            }            i++;        }        return order.size() == numCourses?order.stream().mapToInt(j->j).toArray(): new int[0];    }}