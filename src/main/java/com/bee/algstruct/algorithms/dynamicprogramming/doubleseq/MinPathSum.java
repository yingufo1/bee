package com.bee.algstruct.algorithms.dynamicprogramming.doubleseq;/** * 剑指 Offer II 099. 最小路径之和:https://leetcode.cn/problems/0i0mDW/ * * @author yangying * @version 1.0 * @since 2022/6/5 **/public class MinPathSum {    public int minPathSum(int[][] grid) {        int m = grid.length;        int n = grid[0].length;        int[][] dp = new int[grid.length][grid[0].length];        dp[grid.length - 1][grid[0].length - 1] = grid[grid.length - 1][grid[0].length - 1];        for (int i = m - 1; i >= 0; i--) {            for (int j = n - 1; j >= 0; j--) {                minPathSum(grid, i, j, dp);            }        }        return dp[0][0];    }    private void minPathSum(int[][] grid, int i, int j, int[][] dp) {        if (i == dp.length - 1 && j == dp[0].length - 1) {            dp[i][j] = grid[grid.length - 1][grid[0].length - 1];;            return;        }        if (i == grid.length - 1) {            dp[i][j] = dp[i][j + 1] + grid[i][j];            return;        }        if (j == grid[0].length - 1) {            dp[i][j] = dp[i + 1][j] + grid[i][j];            return;        }        dp[i][j] = Math.min(dp[i][j + 1], dp[i + 1][j]) + grid[i][j];    }    public static void main(String[] args) {        MinPathSum minPathSum = new MinPathSum();        //[[1,2,3],[4,5,6]]        int ans = minPathSum.minPathSum(new int[][]{new int[]{1,2,3},new int[]{4,5,6}});        System.out.println(ans);    }}