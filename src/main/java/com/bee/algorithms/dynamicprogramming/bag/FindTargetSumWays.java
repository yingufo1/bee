package com.bee.algorithms.dynamicprogramming.bag;/** * 剑指 Offer II 102. 加减的目标值：https://leetcode.cn/problems/YaVDxD/ * * @author yangying * @version 1.0 * @since 2022/6/7 **/public class FindTargetSumWays {    public int findTargetSumWays(int[] nums, int target) {        //回溯法实现        backTrack(nums, target);        //动态规划法实现        return dp(nums, target);    }    /**     * 令sum = nums所有元素之和，sum = target的条件是：nums中有neg个元素是-1，所以也有neg个元素是+1，所以target=diff=target-2*neg。     * 所以，neg = (sum-target)/2.即转换为能否从nums中选取neg个元素是-1，可用背包解法。     *     * @param nums     * @param target     * @return     */    private int dp(int[] nums, int target) {        int sum = 0;        for (int num : nums) {            sum += num;        }        if (sum < target) { //1的个数不够，不能取到target            return 0;        }        int neg = sum - target;        if (neg % 2 != 0) {//如果neg不能被2除尽，说明不能取到正负1相等，也就不能取到target            return 0;        }        neg = neg / 2;        int[][] dp = new int[nums.length + 1][neg + 1];//转换为背包问题，dp用于存储从0到i个元素中选取等于j的选择数量。        dp[0][0] = 1;        int cout;        for (int i = 0; i < nums.length; i++) {            int k = nums[i];            for (int j = 0; j <= neg; j++) {                /**                 * dp[i + 1][j] = dp[i][j]，当j<num[i]时，因为只能选择-1；当j>=num[i]并且不选取num[i]时。                 * dp[i + 1][j] = dp[i][j]+dp[i][j-num]，当j>=num[i]并且选取num[i]时                 */                dp[i + 1][j] = dp[i][j];//如果j<k，则不能选择num[i]，因为是选择-1;如果j>=k,不选num[i],那么                if (j >= k) {                    dp[i + 1][j] += dp[i][j - k];                }            }        }        return dp[nums.length][neg];    }    private int backTrack(int[] nums, int target) {        int[] dp = new int[1];        findTargetSumWays(nums, target, 0, 0, dp);        return dp[0];    }    private void findTargetSumWays(int[] nums, int target, int rest, int i, int[] dp) {        if (i == nums.length) {            //System.out.println(rest);            if (rest == target) {                dp[0] = dp[0] + 1;            }            return;        }        rest = rest + nums[i];        findTargetSumWays(nums, target, rest, i + 1, dp);        rest = rest - nums[i];        findTargetSumWays(nums, target, rest - nums[i], i + 1, dp);    }    public static void main(String[] args) {        FindTargetSumWays f = new FindTargetSumWays();        int ans = f.findTargetSumWays(new int[]{1, 1, 1, 1, 1}, 3);        System.out.println(ans);    }}